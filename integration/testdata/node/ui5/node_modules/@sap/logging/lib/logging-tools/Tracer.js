'use strict';

var _ = require('lodash');
var util = require('util');
var assert = require('assert');
var common = require('./common');
var constants = require('../constants');
var normalizeComponent = require('../common').normalizeComponent;


module.exports = Tracer;

function Tracer(reqContext, location) {
  this._reqContext = reqContext;
  this._location = resolveLocation(location);
  this._winston = reqContext._appContext._winstonTracer;
  this._mainTransportName = constants.TRANSPORT_NAMES.TRACER;
}

function resolveLocation(location) {
  assert(_.isString(location), 'Location should be a string');
  return normalizeComponent(location);
}

Tracer.prototype.getLevel = function () {
  var levelsContainer = this._reqContext._appContext._levelsContainer;
  return levelsContainer.getTracerLevel(this._location);
};

Tracer.prototype.entering = function (fnName) {
  checkFunctionName(fnName);
  if (!this.isEnabled('path')) {
    return;
  }
  var message = 'Entering function "' + fnName + '"';
  if (arguments.length > 1) {
    message += ' with arguments: ';
    message += Array.prototype.slice.call(arguments, 1).map(util.inspect).join(', ');
  }
  this._traceEntry('path', [message]);
};

Tracer.prototype.exiting = function (fnName) {
  checkFunctionName(fnName);
  if (!this.isEnabled('path')) {
    return;
  }
  var message = 'Exiting function "' + fnName + '"';
  if (arguments.length > 1) {
    message += ' with result: ' + util.inspect(arguments[1]);
  }
  this._traceEntry('path', [message]);
};

Tracer.prototype.throwing = function (fnName, error) {
  checkFunctionName(fnName);
  if (!this.isEnabled('path')) {
    return;
  }
  var message = 'Function "' + fnName + '" throwing';
  this._traceEntry('path', error ? [error, message] : [message]);
};

Tracer.prototype.catching = function (fnName, error) {
  checkFunctionName(fnName);
  if (!this.isEnabled('path')) {
    return;
  }
  var message = 'Function "' + fnName + '" catching';
  this._traceEntry('path', error ? [error, message] : [message]);
};

function checkFunctionName(fnName) {
  assert(_.isString(fnName), 'Function name should be a string');
}

Tracer.prototype._traceEntry = function (levelName, arrArgs) {
  var levelsContainer = this._reqContext._appContext._levelsContainer;
  this._winston.transports[this._mainTransportName].level = levelsContainer.getTracerLevel(this._location);
  outputTraceEntry(this, levelName, arrArgs);
};

Tracer.prototype._traceLogEntry = function (levelName, arrArgs) {
  this._winston.transports[this._mainTransportName].level = levelName;
  outputTraceEntry(this, levelName, arrArgs);
};

function outputTraceEntry(tracer, levelName, arrArgs) {
  var error;
  arrArgs = arrArgs.slice(); // do not modify the original
  if (common.isError(arrArgs[0])) {
    error = arrArgs.shift();
  }
  var message = common.createMessage(arrArgs);
  var meta = {
    messageContext: {
      reqContext: tracer._reqContext._shorten(),
      location: tracer._location,
      error: error
    }
  };
  tracer._winston[levelName](message, meta);
}

function addFunctionForEveryLevel(proto, availableLevels) {
  Object.keys(availableLevels).forEach(function (levelName) {
    proto[levelName] = function () {
      if (!this.isEnabled(levelName)) {
        return;
      }
      var arrArgs = Array.prototype.slice.call(arguments);
      this._traceEntry(levelName, arrArgs);
    };
  }, this);
}

addFunctionForEveryLevel(Tracer.prototype, constants.TRACE_LEVELS);

Tracer.prototype.isEnabled = function (level) {
  var levelsContainer = this._reqContext._appContext._levelsContainer;
  var currentLevel = levelsContainer.getTracerLevel(this._location);
  return common.genericIsEnabled(level, constants.TRACE_LEVELS, currentLevel);
};

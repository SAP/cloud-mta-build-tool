'use strict';

var assert = require('assert');
var crypto = require('crypto');
var util = require('util');

module.exports = {
  validate: {
    provided: function (value, name) {
      assert(value !== undefined, util.format('%s should be provided', name));
    },
    string: function (value, name) {
      assert(typeof value === 'string', util.format('%s should be a string', name));
    },
    notEmptyString: function (value, name) {
      this.string(value, name);
      assert(value.length, util.format('%s should not be empty', name));
    },
    boolean: function (value, name) {
      assert(typeof value === 'boolean', util.format('%s should be a boolean', name));
    },
    object: function (obj, name) {
      assert(obj && typeof obj === 'object', util.format('%s should be a JavaScript object', name));
    },
    callback: function (callback) {
      assert(typeof callback === 'function', 'Callback should be a function');
    },
    attributeName: function (attributes, name) {
      if (attributes.some(function(attribute) { return attribute.name === name; })) {
        throw new Error('Attribute names must be unique');
      }
    },
    attributesLength: function (attributes) {
      assert(attributes.length > 0, 'At least 1 attribute should be provided');
    },
    objectWithTypeAndId: function (obj, name) {
      this.object(obj, name);
      this.notEmptyString(obj.type, util.format('%s/type', name));
      this.object(obj.id, util.format('%s/id', name));
      assert(Object.keys(obj.id).length > 0, util.format('%s/id should have at least one property', name));
      Object.keys(obj.id).forEach(function (key) {
        this.notEmptyString(obj.id[key], util.format('%s/id/%s', name, key));
      }, this);
    }
  },

  uuid: function() {
    return crypto.randomBytes(16).toString('hex').toUpperCase();
  }
};

'use strict';

var constants = require('@sap/xssec/lib/constants');
var request = require('request');
var url = require('url');

// use environment variable DEBUG with value 'xssec:*' for trace/error messages
var debug = require('debug');
var debugTrace = debug('xssec:securitycontext');
var debugError = debug('xssec:securitycontext');

var keycache = require('@sap/xssec/lib/keycache');

// Note: the keycache is initialized currently with the default size defined in constants
//       Consider making this configurable for the application, e.g. via xssecurity.json
//       or (probably worse) via environment variables.
//       Similarly, the keycache uses the default expiration time for cache entries as 
//       defined in constants. Also here, consider making this configurable. 
var keyCache = new keycache.KeyCache(constants.KEYCACHE_DEFAULT_CACHE_SIZE, constants.KEYCACHE_DEFAULT_CACHE_ENTRY_EXPIRATION_TIME_IN_MINUTES);

debugError.log = console.error.bind(console);
debugTrace.log = console.log.bind(console);

exports.createSecurityContext = createSecurityContext;

function createSecurityContext(token, config, cb) {
    var securityContext;

    try {
        securityContext = new SecurityContext(token, config);
        securityContext.init(done);
    } catch (e) {
        cb(e);
    }

    function done(err) {
        if (err) {
            return cb(err);
        }
        cb(null, securityContext);
    }
}

function SecurityContext(token, config) {
    this.token = token;
    this.config = config;
    this.xsappname = '';
    this.isForeignMode = false;
    this.tokenContainsAttributes = false;
    this.tokenContainsAdditionalAuthAttributes = false;
    this.userInfo = {
        logonName : '',
        givenName : '',
        familyName : '',
        email : ''
    };
    this.scopes = [];
    this.samlToken = '';
    this.clientId = '';
    this.identityZone = '';
    this.subdomain = null;
    this.origin = null;
    this.userAttributes = '';
    this.additionalAuthAttributes = '';
    this.serviceinstanceid = null;
    this.grantType = '';

    // sapssoext
    var ssojwt;
    if (process.sapnodejwtlib) {
        this.ssojwt = process.sapnodejwtlib;
    } else {
        try {
            var jwt = require('@sap/node-jwt');
            this.ssojwt = process.sapnodejwtlib = new jwt("");
        } catch (e) {
            var error = new Error('No jwt.node available. Error: ' + e.message );
            error.statuscode = 500; //No jwt.node
            throw error;
        }
    }

    // validate config input
    debugTrace('\nConfiguration (note: clientsecret might be contained but is not traced): ' + JSON.stringify(config, credentialsReplacer, 4));
    if (!this.ssojwt || this.ssojwt.getLibraryVersion() === -1) {
        debugTrace('\nSSO library path: ' + process.env['SSOEXT_LIB']);
        var error = new Error('JWT validation library could not be loaded. Used '
                + process.env['SSOEXT_LIB']);
        error.statuscode = 500; //lib not found
        throw error;
    }

    // validate config input
    if (!token || token.length === 0) {
        var error = new Error('Invalid token (empty).');
        error.statuscode = 401; //(Token Empty/No Token)
        throw error;
    }
    if (!config) {
        var error = new Error('Invalid config (missing).');
        error.statuscode = 500; //500 (Invalid config)
        throw error;
    }
    if (!this.config.clientid) {
        var error = new Error('Invalid config: Missing clientid.');
        error.statuscode = 500; //500 (Invalid config)
        throw error;
    }
    if (!this.config.clientsecret) {
        var error = new Error('Invalid config: Missing clientsecret.');
        error.statuscode = 500; //500 (Invalid config)
        throw error;
    }
    if (!this.config.url) {
        var error = new Error('Invalid config: Missing url.');
        error.statuscode = 500; //500 (Invalid config)
        throw error;
    }
    if (!this.config.xsappname) {
        if (!process.env.XSAPPNAME) {
            var errorString = 'Invalid config: Missing xsappname.\n'
                    + 'The application name needs to be defined in xs-security.json.';
            debugError('\n' + errorString);
            var error = new Error(errorString);
            error.statuscode = 500; //500 (Invalid config)
            throw error;
        } else {
            this.xsappname = process.env.XSAPPNAME;
            debugTrace('\nXSAPPNAME defined in manifest.yml (legacy).\n'
                    + 'You should switch to defining xsappname in xs-security.json.');
        }
    } else {
        if (!process.env.XSAPPNAME) {
            this.xsappname = this.config.xsappname;
        } else {
            if (process.env.XSAPPNAME == this.config.xsappname) {
                this.xsappname = process.env.XSAPPNAME;
                debugTrace('\nThe application name is defined both in the manifest.yml (legacy) \n'
                        + 'as well as in xs-security.json. Remove it in manifest.yml.');
            } else {
                var errorString = 'Invalid config: Ambiguous xsappname.\n'
                        + 'The application name is defined with different values in the manifest.yml (legacy)\n'
                        + 'as well as in xs-security.json. Remove it in manifest.yml.';
                debugError('\n' + errorString);
                var error = new Error(errorString);
                error.statuscode = 500; //500 (Invalid config)
                throw error;
            }
        }
    }
}

SecurityContext.prototype.init = function init(cb) {
    var self = this;

    offlineValidation(
            self.token,
            self.config,
            self.ssojwt,
            function(error, result) {
                if (error) {
                    debugError(error.message);
                    debugError(error.stack);
                    return cb(error, null);
                }

                if (!result.cid) {
                    var errorString = 'Client Id not contained in access token. Giving up!';
                    debugError('\n' + errorString);
                    var error = new Error(errorString);
                    error.statuscode = 400; //400 (no clientID)
                    return cb(error, null);
                }
                if (!result.zid) {
                    var errorString = 'Identity Zone not contained in access token. Giving up!';
                    debugError('\n' + errorString);
                    var error = new Error(errorString);
                    error.statuscode = 400; //400 (wrong idz)
                    return cb(error, null);
                }

                var applicationPlan = false;
                if (result.cid.indexOf('!t') !== -1) {
                    applicationPlan = true;
                }
                if ((result.cid === self.config.clientid)
                        && (result.zid === self.config.identityzoneid || applicationPlan === true)) {
                    // clientid and identity zone of the token must match with the values of the application
                    // (if the token was issued for the xsuaa application plan it is sufficient that the clientid matches)
                    if (applicationPlan === false) {
                        debugTrace('\nClient Id and Identity Zone of the access token match\n'
                                + 'with the current application\'s Client Id and Zone.');
                    } else {
                        debugTrace('\nClient Id of the access token (XSUAA application plan) matches\n'
                                + 'with the current application\'s Client Id.');
                    }
                    self.isForeignMode = false;
                } else if (self.config.trustedclientidsuffix && self.config.trustedclientidsuffix.length > 0 &&
                        result.cid.substring(result.cid.length - self.config.trustedclientidsuffix.length, result.cid.length) === self.config.trustedclientidsuffix) {
                    debugTrace('\nClient Id "' + result.cid + '" of the access token allows consumption by the Client Id "' +
                            self.config.clientid + '" of the current application\n');
                    self.isForeignMode = false;
                } else if (process.env.SAP_JWT_TRUST_ACL) {
                    debugTrace('\nClient Id "'
                            + result.cid
                            + '" and/or Identity Zone "'
                            + result.zid
                            + '" of the access token\n'
                            + 'does/do not match with the Client Id "'
                            + self.config.clientid
                            + '" and Identity Zone "'
                            + self.config.identityzoneid
                            + '"\nof the current application.\n'
                            + 'Validating token against JWT trust ACL (SAP_JWT_TRUST_ACL).');
                    var parsedACL;
                    try {
                        parsedACL = JSON.parse(process.env.SAP_JWT_TRUST_ACL);
                    } catch (er) {
                        var errorString = 'JWT trust ACL (ACL SAP_JWT_TRUST_ACL):\n'
                                + process.env.SAP_JWT_TRUST_ACL
                                + '\ncould not be parsed successfully.\n'
                                + 'Error: ' + er.message;
                        debugError('\n' + errorString);
                        var error = new Error(errorString);
                        error.statuscode = 500; //500 (Internal Server Error)
                        return cb(error, null);
                    }
                    var foundMatch = false;
                    for ( var aclEntry in parsedACL) {
                        if (((result.cid === parsedACL[aclEntry].clientid) || ('*' === parsedACL[aclEntry].clientid))
                                && ((result.zid === parsedACL[aclEntry].identityzone) || ('*' === parsedACL[aclEntry].identityzone))) {
                            foundMatch = true;
                            break;
                        }
                    }
                    if (foundMatch) {
                        debugTrace('\nForeign token received, but matching entry\n'
                                + 'in JWT trust ACL (SAP_JWT_TRUST_ACL) found.');
                        self.isForeignMode = true;
                    } else {
                        var errorString = 'Client Id "'
                                + result.cid
                                + '" and/or Identity Zone "'
                                + result.zid
                                + '" of the access token\n'
                                + 'does/do not match with the Client Id "'
                                + self.config.clientid
                                + '" and Identity Zone "'
                                + self.config.identityzoneid
                                + '" of the current application.\n'
                                + 'No match found in JWT trust ACL (SAP_JWT_TRUST_ACL):\n'
                                + JSON.stringify(parsedACL, null, 4);
                        debugError('\n' + errorString);
                        var error = new Error(errorString);
                        error.statuscode = 403; //403 Forbidden (as no JWT trust entry)
                        return cb(error, null);
                    }
                } else {
                    if (result.cid !== self.config.clientid) {
                        var errorString = 'Client Id of the access token "'
                                + result.cid
                                + '" does not match with\nthe OAuth Client Id "'
                                + self.config.clientid
                                + '" of the application.\n'
                                + 'No JWT trust ACL (SAP_JWT_TRUST_ACL) specified in environment.';
                        debugError('\n' + errorString);
                        var error = new Error(errorString);
                        error.statuscode = 403; //403 Forbidden (as client IDs do not match and no trust entry exists)
                        return cb(error, null);
                    } else {
                        var errorString = 'Identity Zone of the access token "'
                                + result.zid
                                + '" does not match\nwith the Identity Zone "'
                                + self.config.identityzoneid
                                + '" of the application.\n'
                                + 'No JWT trust ACL (SAP_JWT_TRUST_ACL) specified in environment.';
                        debugError('\n' + errorString);
                        var error = new Error(errorString);
                        error.statuscode = 403; //403 Forbidden (as identity zones do not match and no trust entry exists)
                        return cb(error, null);
                    }
                }
                debugTrace('\nApplication received a token of grant type "' + result.grant_type + '".');
                self.identityZone = result.zid;
                self.clientId = result.cid;
                if (result.origin !== null && result.origin !== undefined) {
                    self.origin = result.origin;
                }
                self.expirationDate = new Date(result.exp * 1000);
                self.grantType = result.grant_type;
                if (self.grantType !== constants.GRANTTYPE_CLIENTCREDENTIAL) {
                    self.userInfo.logonName = result.user_name; // jshint ignore:line
                    if (result.hasOwnProperty('ext_attr') && result.ext_attr.given_name !== undefined) {
                        self.userInfo.givenName = result.ext_attr.given_name;
                    } else {
                        self.userInfo.givenName = result.given_name; // jshint ignore:line
                    }
                    if (result.hasOwnProperty('ext_attr') && result.ext_attr.family_name !== undefined) {
                        self.userInfo.familyName = result.ext_attr.family_name;
                    } else {
                        self.userInfo.familyName = result.family_name; // jshint ignore:line
                    }
                    self.userInfo.email = result.email;
                    debugTrace('\nObtained logon name: ' + self.userInfo.logonName);
                    debugTrace('Obtained given name: ' + self.userInfo.givenName);
                    debugTrace('Obtained family name: ' + self.userInfo.familyName);
                    debugTrace('Obtained email: ' + self.userInfo.email);
                    if (result.hasOwnProperty('ext_cxt')) {
                        if (result.ext_cxt['hdb.nameduser.saml'] !== undefined) {
                            self.samlToken = result.ext_cxt['hdb.nameduser.saml'];
                        }
                        if (result.ext_cxt['xs.user.attributes'] !== undefined) {
                            self.userAttributes = result.ext_cxt['xs.user.attributes'];
                            self.tokenContainsAttributes = true;
                            debugTrace('\nObtained attributes: '
                                    + JSON.stringify(self.userAttributes, null, 4));
                        } else {
                            self.tokenContainsAttributes = false;
                            debugTrace('\nObtained attributes: no XS user attributes in JWT token available.');
                        }

                    } else {
                        self.samlToken = result['hdb.nameduser.saml'];
                        if (result.hasOwnProperty('xs.user.attributes')) {
                            self.userAttributes = result['xs.user.attributes'];
                            self.tokenContainsAttributes = true;
                            debugTrace('\nObtained attributes: '
                                    + JSON.stringify(self.userAttributes, null, 4));
                        } else {
                            self.tokenContainsAttributes = false;
                            debugTrace('\nObtained attributes: no XS user attributes in JWT token available.');
                        }
                    }
                }
                if (result.hasOwnProperty('az_attr')) {
                    self.additionalAuthAttributes = result['az_attr'];
                    self.tokenContainsAdditionalAuthAttributes = true;
                    debugTrace('\nObtained additional authentication attributes: '
                            + JSON.stringify(self.additionalAuthAttributes, null, 4));
                } else {
                    self.tokenContainsAdditionalAuthAttributes = false;
                    debugTrace('\nObtained attributes: no additional authentication attributes in JWT token available.');
                }
                if (result.hasOwnProperty('ext_attr') && result.ext_attr.serviceinstanceid !== undefined) {
                    self.serviceinstanceid = result.ext_attr.serviceinstanceid;
                }
                if (result.hasOwnProperty('ext_attr') && result.ext_attr.zdn !== undefined) {
                    self.subdomain = result.ext_attr.zdn;
                }
                debugTrace('\nObtained subdomain: ' + self.subdomain);
                debugTrace('Obtained serviceinstanceid: ' + self.serviceinstanceid);
                debugTrace('Obtained origin: ' + self.origin);
                self.scopes = result.scope;
                debugTrace('Obtained scopes: '
                        + JSON.stringify(self.scopes, null, 4));
                cb();
            });
};

SecurityContext.prototype.getIdentityZone = function() {
    return this.identityZone;
};

SecurityContext.prototype.getSubaccountId = function() {
    return this.identityZone;
};

SecurityContext.prototype.getSubdomain = function() {
	return this.subdomain;
};

SecurityContext.prototype.getClientId = function() {
	return this.clientId;
};

SecurityContext.prototype.getExpirationDate = function() {
    return this.expirationDate;
};

SecurityContext.prototype.getOrigin = function() {
    return this.origin;
};

SecurityContext.prototype.getLogonName = function() {
    try {
        forbidClientCredentialsToken('SecurityContext.getLogonName', this.grantType);
    } catch (e) {
        return null;
    }
    return this.userInfo.logonName;
};

SecurityContext.prototype.getGivenName = function() {
    try {
        forbidClientCredentialsToken('SecurityContext.getGivenName', this.grantType);
    } catch (e) {
        return null;
    }
    return this.userInfo.givenName;
};

SecurityContext.prototype.getFamilyName = function() {
    try {
        forbidClientCredentialsToken('SecurityContext.getFamilyName', this.grantType);
    } catch (e) {
        return null;
    }
    return this.userInfo.familyName;
};

SecurityContext.prototype.getEmail = function() {
    try {
        forbidClientCredentialsToken('SecurityContext.getEmail', this.grantType);
    } catch (e) {
        return null;
    }
    return this.userInfo.email;
};

SecurityContext.prototype.getToken = function(namespace, name) {
    if (this.tokenContainsAttributes && this.isForeignMode) {
        debugTrace('\nThe SecurityContext has been initialized with an access token of a\n'
                + 'foreign OAuth Client Id and/or Identity Zone. Furthermore, the \n'
                + 'access token contains attributes. Due to the fact that we want to\n'
                + 'restrict attribute access to the application that provided the \n'
                + 'attributes, the getToken function does not return a valid token.\n');
        return null;
    }
    if (namespace === undefined || namespace === null) {
        debugTrace('\nInvalid token namespace (may not be null or undefined).');
        return null;
    } else if (namespace !== constants.SYSTEM) {
        debugTrace('\nNamespace "' + namespace + '" not supported.');
        return null;
    }
    if (name === undefined || name === null) {
        debugTrace('\nInvalid token name (may not be null or undefined).');
        return null;
    }
    switch (name) {
    case constants.JOBSCHEDULER:
        return this.token;
    case constants.HDB:
        if (this.samlToken === undefined || this.samlToken === null) {
            return this.token;
        } else {
            return this.samlToken;
        }
    default:
        debugTrace('\nToken name "' + name + '" not supported.');
        return null;
    }
};

SecurityContext.prototype.getHdbToken = function() {
    return this.getToken(constants.SYSTEM, constants.HDB);
}

SecurityContext.prototype.getAppToken = function() {
    return this.token;
}

SecurityContext.prototype.requestTokenForClient = function(serviceCredentials, scopes, cb) {
    return requestUserToken(this, serviceCredentials, null, scopes, false, cb);
}

SecurityContext.prototype.requestToken = function(serviceCredentials, type, additionalAttributes, cb) {
    if (type === constants.TYPE_USER_TOKEN) {
        return requestUserToken(this, serviceCredentials, additionalAttributes, null, true, cb);
    } else if (type === constants.TYPE_CLIENT_CREDENTIALS_TOKEN) {
        return requestClientCredentialsToken(this, serviceCredentials, additionalAttributes, cb);
    } else {
        var error = new Error('Invalid grant type.');
        return cb(error, null);
    }
}

SecurityContext.prototype.getAttribute = function(name) {
    try {
        forbidClientCredentialsToken('SecurityContext.getAttribute', this.grantType);
    } catch (e) {
        return null;
    }
    if (!this.tokenContainsAttributes) {
        debugTrace('\nThe access token contains no user attributes.\n');
        return null;
    }
    if (this.isForeignMode) {
        debugTrace('\nThe SecurityContext has been initialized with an access token of a\n'
                + 'foreign OAuth Client Id and/or Identity Zone. Furthermore, the \n'
                + 'access token contains attributes. Due to the fact that we want to\n'
                + 'restrict attribute access to the application that provided the \n'
                + 'attributes, the getAttribute function does not return any attributes.\n');
        return null;
    }
    if (name === undefined || name === null || name === '') {
        debugTrace('\nInvalid attribute name (may not be null, empty, or undefined).');
        return null;
    }
    if (!this.userAttributes.hasOwnProperty(name)) {
        debugTrace('\nNo attribute "' + name + '" found for user "'
                + this.userInfo.logonName + '".');
        return null;
    }
    return this.userAttributes[name];
};

SecurityContext.prototype.getAdditionalAuthAttribute = function(name) {
    if (!this.tokenContainsAdditionalAuthAttributes) {
        debugTrace('\nThe access token contains no additional authentication attributes.\n');
        return null;
    }
    if (name === undefined || name === null || name == '') {
        debugTrace('\nInvalid attribute name (may not be null, empty, or undefined).');
        return null;
    }
    if (!this.additionalAuthAttributes.hasOwnProperty(name)) {
        debugTrace('\nNo attribute "' + name + '" found as additional authentication attribute.');
        return null;
    }
    return this.additionalAuthAttributes[name];
};

SecurityContext.prototype.getCloneServiceInstanceId = function() {
    return this.serviceinstanceid;
};

SecurityContext.prototype.isInForeignMode = function() {
    return this.isForeignMode;
};

SecurityContext.prototype.hasAttributes = function() {
    try {
        forbidClientCredentialsToken('SecurityContext.hasAttributes', this.grantType);
    } catch (e) {
        return null;
    }
    return this.tokenContainsAttributes;
};

SecurityContext.prototype.checkLocalScope = function(scope) {
    var scopeName = this.xsappname + '.' + scope;
    if ((scope === null) || (scope === undefined)) {
        return false;
    }
    return this.scopes.indexOf(scopeName) !== -1;
};

SecurityContext.prototype.getGrantType = function() {
    return this.grantType;
};

SecurityContext.prototype.checkScope = function(scope) {
    var scopeName = scope;

    if ((scope === null) || (scope === undefined)) {
        return false;
    }
    if (scopeName.substring(0, constants.XSAPPNAMEPREFIX.length) === constants.XSAPPNAMEPREFIX) {
        scopeName = scopeName.replace(constants.XSAPPNAMEPREFIX, this.xsappname + '.');
    }
    return this.scopes.indexOf(scopeName) !== -1;
};

function loadVerificationKey(accessToken, config, cb) {
    if (config.verificationkey === undefined) {
        var error = new Error('Error in offline validation of access token, because of missing verificationkey', null);
        error.statuscode = 500; //500 (missing verificationkey)
        return cb(error);
    }
    var uaaURLString = config.url;
    var invalidatedTokenHeaderJSON = null;
    try {
        var invalidatedTokenParts = accessToken.split('.');
        if (invalidatedTokenParts.length !== 3) {
            var error = new Error('Unexpected JWT structure.', null);
            error.statuscode = 400; 
            return cb(error);
        }
        var invalidatedTokenHeaderBuffer = new Buffer(invalidatedTokenParts[0], 'base64');
        var invalidatedTokenHeaderString = invalidatedTokenHeaderBuffer.toString('ascii');
        invalidatedTokenHeaderJSON = JSON.parse(invalidatedTokenHeaderString);
        if (!invalidatedTokenHeaderJSON.kid || invalidatedTokenHeaderJSON.kid == 'legacy-token-key') {
            return cb(null, config.verificationkey);
        }
        
        var invalidatedTokenContentBuffer = new Buffer(invalidatedTokenParts[1], 'base64');
        var invalidatedTokenContentString = invalidatedTokenContentBuffer.toString('ascii');
        var invalidatedTokenContentJSON = JSON.parse(invalidatedTokenContentString);
        if (!invalidatedTokenContentJSON.iss) {
            var error = new Error('JWT token contains no iss field. Giving up.', null);
            error.statuscode = 400; 
            return cb(error);
        }
        var tokenIssuer = invalidatedTokenContentJSON.iss;
        var tokenIssuerURL = url.parse(tokenIssuer);
        var tokenIssuerURLHostname = tokenIssuerURL.hostname;
        var tokenIssuerURLIDZIndex = tokenIssuerURLHostname.indexOf('.');
        if (tokenIssuerURLIDZIndex < 0) {
            debugTrace('\nUnexpected Issuer Format in JWT. Use legacy-token-key.');
            return cb(null, config.verificationkey);
        }
        var tokenIssuerIDZ = tokenIssuerURLHostname.substring(0, tokenIssuerURLIDZIndex);
        debugTrace('\nIdentity zone of token issuer: '+tokenIssuerIDZ+'\n');
        var uaaURL = url.parse(uaaURLString);
        var uaaURLHostname = uaaURL.hostname;
        var uaaURLIDZIndex = uaaURLHostname.indexOf('.');
        if (uaaURLIDZIndex < 0) {
            var error = new Error('Unexpected format of UAA URL in configuration. Giving up.', null);
            error.statuscode = 500; 
            return cb(error);
        }
        var uaaURLHostnameWithoutIDZ = uaaURLHostname.substring(uaaURLIDZIndex, uaaURLHostname.length);
        var newHostname = tokenIssuerIDZ + uaaURLHostnameWithoutIDZ;
        uaaURL.hostname = newHostname;
        uaaURL.host = null;
        uaaURLString = url.format(uaaURL);
        return keyCache.getKey(invalidatedTokenHeaderJSON.kid, uaaURLString, cb);
    } catch (e) {
        e.statuscode = 403;
        return cb(e);
    }
}

function checkTokenLocal(accessToken, verificationkey, ssojwt, cb) {
   
    var ssorc = ssojwt.loadPEM(verificationkey);
    
    if ((ssorc !== 0) && (ssorc === 9)) {
        debugTrace('\nSSO library path:    ' + process.env['SSOEXT_LIB']);
        debugTrace('\nCCL library path:    ' + process.env['SSF_LIB']);
        debugTrace('\nSSO library version: ' + ssojwt.getLibraryVersion());
        debugTrace('\nSSO library code:    ' + ssojwt.getErrorRC());
        var error = new Error('Error in sapssoext, version : '
                + ssojwt.getLibraryVersion() + ' . Cannot load CCL from path: '
                + process.env['SSF_LIB'], null);
        error.statuscode = 500; //500 (lib not found)
        return cb(error);
    }
    ssojwt.checkToken(accessToken);
    if (ssojwt.getErrorDescription() !== "") {
        ssorc = ssojwt.getErrorRC();
        debugTrace('\nSSO library path:    ' + process.env['SSOEXT_LIB']);
        debugTrace('\nCCL library path:    ' + process.env['SSF_LIB']);
        debugTrace('\nSSO library version: ' + ssojwt.getLibraryVersion());
        debugTrace('\nSSO library code:    ' + ssojwt.getErrorRC());
        if ((ssorc !== 0) && (ssorc === 5)) {
            // verification key and JWT are not valid, no library error
            debugTrace('\nInvalid JWT:    ' + accessToken);
            var error = new Error(
                    'Invalid access token. Validation error: '
                    + ssojwt.getErrorDescription(), null);
            error.statuscode = 403; //403 (validation error)
            return cb(error);
        } else {
            var error = new Error(
                    'Error in offline validation of access token: '
                    + ssojwt.getErrorDescription(), null);
            error.statuscode = 403; //403 (validation error)
            return cb(error);
        }
    }
    var parsedPayload = null;
    try {
        parsedPayload = JSON.parse(ssojwt.getJWPayload());
    } catch (er) {
        var errorString = 'Access token payload could not be parsed successfully.\n'
                + 'Error: ' + er.message;
        debugError('\n' + errorString);
        var error = new Error(errorString);
        error.statuscode = 400; //400 (parsing error)
        return cb(error, null);
    }
    cb(null, parsedPayload);
}

function offlineValidation(accessToken, config, ssojwt, cb) {
    loadVerificationKey(accessToken, config, function(err, verificationkey) {
        if (err) {
            return cb(err);
        }
        checkTokenLocal(accessToken, verificationkey, ssojwt, cb);
    });
}

function credentialsReplacer(key, value) {
    if (key === 'clientsecret') {
        return undefined;
    } else {
        return value;
    }
}

function requestUserToken(securityContext, serviceCredentials, additionalAttributes, scopes, adaptSubdomain, cb) {
    // input validation
    if (!serviceCredentials) {
        var error = new Error('Parameter serviceCredentials is missing but mandatory.');
        return cb(error, null);
    }
    if (!serviceCredentials.clientid || !serviceCredentials.clientsecret) {
        var error = new Error('Invalid service credentials: Missing clientid/clientsecret.');
        return cb(error, null);
    }
    if (!serviceCredentials.url) {
        var error = new Error('Invalid service credentials: Missing url.');
        return cb(error, null);
    }
    if (securityContext.checkScope('uaa.user') === false) {
        var error = new Error('JWT token does not include scope "uaa.user".');
        return cb(error, null);
    }
    // adapt subdomain in service url, if necessary
    var urlWithCorrectSubdomain = serviceCredentials.url;
    if (adaptSubdomain === true) {
        var tokenSubdomain = securityContext.getSubdomain();
        var tokenRequestSubdomain = null;
        var uaaUrl = url.parse(serviceCredentials.url);
        if (uaaUrl.hostname.indexOf('.') === -1) {
            tokenRequestSubdomain = null;
        } else {
            tokenRequestSubdomain = uaaUrl.hostname.substring(0, uaaUrl.hostname.indexOf('.'));
        }
        if (tokenSubdomain !== null && tokenRequestSubdomain != null && tokenSubdomain !== tokenRequestSubdomain) {
            urlWithCorrectSubdomain = uaaUrl.protocol + "//" + tokenSubdomain + uaaUrl.host.substring(uaaUrl.host.indexOf('.'), uaaUrl.host.size);
        }
    }
    // user token flow
    var options = {
        url : urlWithCorrectSubdomain + '/oauth/token?grant_type=user_token&response_type=token&client_id=' + serviceCredentials.clientid,
        headers: { Accept: 'application/json' },
        auth: {
            bearer: securityContext.token
        }
    };
    if (scopes !== null) {
        options.url = options.url + "&scope=" + scopes;
    }
    if (additionalAttributes !== null) {
        var authorities = { "az_attr" : additionalAttributes };
        options.url = options.url + "&authorities=" + encodeURIComponent(JSON.stringify(authorities));
    }
    request.post(
        options,
        function(error, response, body) {
            if (error) {
                debugError(error.message);
                debugError(error.stack);
                return cb(error, null);
            }
            if (response.statusCode === 401) {
                debugTrace('requestToken: Call to /oauth/token was not successful (grant_type: user_token). Bearer token invalid, requesting client does not have grant_type=user_token or no scopes were granted.');
                return cb(new Error('Call to /oauth/token was not successful (grant_type: user_token). Bearer token invalid, requesting client does not have grant_type=user_token or no scopes were granted.'), null);
            }
            if (response.statusCode !== 200) {
                debugTrace('requestToken: Call to /oauth/token was not successful (grant_type: user_token). HTTP status code: ' + response.statusCode);
                return cb(new Error('Call to /oauth/token was not successful (grant_type: user_token). HTTP status code: ' + response.statusCode), null);
            }
            var json = null;
            try {
                json = JSON.parse(body);
            } catch (e) {
                return cb(e, null);
            }
            // refresh token flow
            options = {
                url : urlWithCorrectSubdomain + '/oauth/token?grant_type=refresh_token&refresh_token=' + json.refresh_token,
                headers: { Accept: 'application/json' },
                auth: {
                    user: serviceCredentials.clientid,
                    pass: serviceCredentials.clientsecret
                }
            };
            request.post(
                options,
                function(error, response, body) {
                    if (error) {
                        debugError(error.message);
                        debugError(error.stack);
                        return cb(error, null);
                    }
                    if (response.statusCode === 401) {
                        debugTrace('requestToken: Call to /oauth/token was not successful (grant_type: refresh_token). Client credentials invalid.');
                        return cb(new Error('Call to /oauth/token was not successful (grant_type: refresh_token). Client credentials invalid.'), null);
                    }
                    if (response.statusCode !== 200) {
                        debugTrace('requestToken: Call to /oauth/token was not successful (grant_type: refresh_token). HTTP status code: ' + response.statusCode);
                        return cb(new Error('Call to /oauth/token was not successful (grant_type: refresh_token). HTTP status code ' + response.statusCode), null);
                    }
                    var json = null;
                    try {
                        json = JSON.parse(body);
                    } catch (e) {
                        return cb(e, null);
                    }
                    return cb(null, json.access_token)
                }
            );
        }
    );
}

function requestClientCredentialsToken(securityContext, serviceCredentials, additionalAttributes, cb) {
    // input validation
    if (!serviceCredentials) {
        var error = new Error('Parameter serviceCredentials is missing but mandatory.');
        return cb(error, null);
    }
    if (!serviceCredentials.clientid || !serviceCredentials.clientsecret) {
        var error = new Error('Invalid service credentials: Missing clientid/clientsecret.');
        return cb(error, null);
    }
    if (!serviceCredentials.url) {
        var error = new Error('Invalid service credentials: Missing url.');
        return cb(error, null);
    }
    // adapt subdomain in service url, if necessary
    var urlWithCorrectSubdomain = serviceCredentials.url;
    var tokenSubdomain = securityContext.getSubdomain();
    var tokenRequestSubdomain = null;
    var uaaUrl = url.parse(serviceCredentials.url);
    if (uaaUrl.hostname.indexOf('.') === -1) {
        tokenRequestSubdomain = null;
    } else {
        tokenRequestSubdomain = uaaUrl.hostname.substring(0, uaaUrl.hostname.indexOf('.'));
    }
    if (tokenSubdomain !== null && tokenRequestSubdomain != null && tokenSubdomain !== tokenRequestSubdomain) {
        urlWithCorrectSubdomain = uaaUrl.protocol + "//" + tokenSubdomain + uaaUrl.host.substring(uaaUrl.host.indexOf('.'), uaaUrl.host.size);
    }
    // client credentials flow
    var options = {
        url : urlWithCorrectSubdomain + '/oauth/token?grant_type=client_credentials&response_type=token',
        headers: { 'Accept' : 'application/json', 'Content-Type' : 'application/x-www-form-urlencoded' },
        auth: {
            user: serviceCredentials.clientid,
            pass: serviceCredentials.clientsecret
        }
    };
    if (additionalAttributes !== null) {
        var authorities = { "az_attr" : additionalAttributes };
        options.url = options.url + "&authorities=" + encodeURIComponent(JSON.stringify(authorities));
    }
    request.post(
        options,
        function(error, response, body) {
            if (error) {
                debugError(error.message);
                debugError(error.stack);
                return cb(error, null);
            }
            if (response.statusCode === 401) {
                debugTrace(body);
                debugTrace('requestToken: Call to /oauth/token was not successful (grant_type: client_credentials). Client credentials invalid.');
                return cb(new Error('Call to /oauth/token was not successful (grant_type: client_credentials). Client credentials invalid.'), null);
            }
            if (response.statusCode !== 200) {
                debugTrace('requestToken: Call to /oauth/token was not successful (grant_type: client_credentials). HTTP status code: ' + response.statusCode);
                return cb(new Error('Call to /oauth/token was not successful (grant_type: client_credentials). HTTP status code ' + response.statusCode), null);
            }
            var json = null;
            try {
                json = JSON.parse(body);
            } catch (e) {
                return cb(e, null);
            }
            return cb(null, json.access_token);
        }
    );
};

function forbidClientCredentialsToken(functionName, grantType) {
    if (grantType === constants.GRANTTYPE_CLIENTCREDENTIAL) {
        var errorString = '\nCall to ' + functionName + ' not allowed with a token of grant type ' + constants.GRANTTYPE_CLIENTCREDENTIAL + '.';
        debugTrace(errorString);
        throw new Error(errorString);
    }
};



'use strict';

var VError = require('verror').VError;

var backendOptions = require('../backend-request/options');
var cookieHandler = require('../backend-response/cookie-handler');
var traceUtil = require('../utils/trace-util');
var requestTraceEnabled = traceUtil.requestTraceEnabled;
var businessServiceUtils = require('../utils/business-service-utils');
var dynamicRoutingUtils = require('../utils/dynamic-routing-utils');

module.exports = function requestHandler(req, res, next) {
  if (!req.internalUrl) {
    return next();
  }

  var routerConfig = req.routerConfig;
  var serviceTag = req.internalUrl.route.service;
  if (serviceTag && businessServiceUtils.getGrantType(req.internalUrl.route.credentials) === 'user_token'){
    callBackend(req, res, req.session.user.businessServices[serviceTag].accessToken, next);
  } else {
    if (routerConfig.getToken) {
      var startTime = Date.now();
      routerConfig.getToken(req, function (err, accessToken) {
        if (err) {
          return next(err);
        }
        traceGetToken(req.loggingContext, accessToken, startTime);
        callBackend(req, res, accessToken, next);
      });
    } else {
      callBackend(req, res, null, next);
    }
  }
};


function traceGetToken(loggingContext, accessToken, startTime) {
  var tracer = loggingContext.getTracer(__filename);
  var time = Date.now() - startTime;
  if (accessToken) {
    tracer.debug('getToken returned a custom access token in %d ms', time);
  } else {
    tracer.debug('getToken completed in %d ms without a custom access token', time);
  }
}

function callBackend(req, res, accessToken, next) {
  var url = req.internalUrl;
  var backendRequest = backendOptions.getRequest(req, accessToken);
  var requestStats = {};
  var shouldPropagateError = true;
  if (requestTraceEnabled) {
    requestStats.requestStart = Date.now();
  }
  var clientReq = backendRequest();

  if (url.destination.timeout) {
    clientReq.setTimeout(url.destination.timeout);
  }
  clientReq.on('timeout', function () {
    clientReq.abort();
    returnGateWayError(504, next, new VError('Request to %s failed with a timeout', url.href));
  });
  clientReq.on('error', function (err) {
    if (shouldPropagateError) {
      returnGateWayError(502, next, new VError(err, 'error while forwarding request to %s', url.href));
    }
  });
  req.on('error', function (err) {
    returnGateWayError(502, next, new VError(err, 'error in reading from incoming request while forwarding to %s', url.href));
  });

  req.on('aborted', function(){
    shouldPropagateError = false;
    clientReq.abort();
  });
  req.pipe(clientReq);

  if (requestTraceEnabled) {
    clientReq.on('socket', function (socket) {
      requestStats.currentBytesRead = socket.bytesRead;
    });
  }
  clientReq.on('response', function(clientRes) {
    var requests = {
      incomingRequest: req,
      incomingResponse: res,
      outgoingRequest: clientReq,
      outgoingResponse: clientRes
    };
    onResponse(requests, requestStats, next);
  });
}

function onResponse(requests, requestStats, next) {
  var incomingRequest = requests.incomingRequest;
  var incomingResponse = requests.incomingResponse;
  var outgoingRequest = requests.outgoingRequest;
  var outgoingResponse = requests.outgoingResponse;
  var tracer = incomingRequest.loggingContext.getTracer(__filename);

  traceUtil.traceBackendResponse(tracer, outgoingResponse);
  var backendCookies = cookieHandler.processCookies(outgoingResponse.headers['set-cookie']);
  if (incomingRequest.session && backendCookies.sessionCookies.length > 0) {
    cookieHandler.storeSessionCookies(backendCookies.sessionCookies, incomingRequest);
  }
  for (var headerName in outgoingResponse.headers) {
    if (headerName === 'set-cookie') {
      backendCookies.nonSessionCookies.length && incomingResponse.setHeader(headerName, backendCookies.nonSessionCookies);
    } else {
      incomingResponse.setHeader(headerName, outgoingResponse.headers[headerName]);
    }
  }
  attachCacheBusterHeaders(incomingRequest,incomingResponse);
  incomingResponse.statusCode = outgoingResponse.statusCode;
  incomingResponse.statusMessage = outgoingResponse.statusMessage;
  var url = incomingRequest.internalUrl;
  if (url.destination.timeout) {
    outgoingResponse.setTimeout(url.destination.timeout);
  }
  outgoingResponse.on('timeout', function() {
    outgoingRequest.abort();
    returnGateWayError(504, next, new VError('Response from %s failed with a timeout', url.href));
  });
  outgoingResponse.on('error', function(err) {
    returnGateWayError(502, next, new VError(err, 'error while reading from incoming response (backend request to %s)', url.href));
  });
  if (requestTraceEnabled) {
    outgoingResponse.on('end', function () {
      var logger = incomingRequest.loggingContext.getLogger('/request/outgoing');
      var bytesRead = outgoingResponse.connection.bytesRead - requestStats.currentBytesRead;
      logger.info('%s to %s took %d ms to respond with status code %d and %d bytes',
        incomingRequest.method, url.href, Date.now() - requestStats.requestStart, outgoingResponse.statusCode, bytesRead);
    });
  }
  incomingResponse.on('error', function(err) {
    returnGateWayError(502, next, new VError(err, 'error while sending data to outgoing response (backend request to %s)', url.href));
  });
  traceUtil.traceOutgoingResponse(tracer, incomingResponse);
  outgoingResponse.pipe(incomingResponse);
}

function returnGateWayError(status, next, err) {
  err.status = status;
  next(err);
}
function attachCacheBusterHeaders(req,res){
  if (dynamicRoutingUtils.isDynamicRouting() && req.internalUrl &&
      req.internalUrl.route &&
      dynamicRoutingUtils.isHtml5RepoService(req.internalUrl.route.service) &&
      dynamicRoutingUtils.getCacheBusterToken(req)){
    res.setHeader('Cache-Control', ['public','max-age=31536000']);
  }
}

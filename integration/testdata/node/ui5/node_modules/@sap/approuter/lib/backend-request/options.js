'use strict';

var http = require('http');
var https = require('https');
var agents = require('./agents');
var backendHeaders = require('./headers');
var urlUtils = require('../utils/url-utils');
var traceUtil = require('../utils/trace-util');
var stripClientCookies = require('../middleware/strip-client-cookies');
var tough = require('tough-cookie');
var _ = require('lodash');



exports.getLogoutRequest = function (req, accessToken, destination, xsAppDestConfig) {
  var method = xsAppDestConfig.logoutMethod || 'POST';
  var logoutUrl = urlUtils.join(destination.url, xsAppDestConfig.logoutPath);
  var headers = backendHeaders.getHeaders(req, accessToken, destination);
  if (req && req.session && req.session._cookieJar) {
    stripClientCookies(req, req.app.get('cookieName'));
    var jar = _.cloneDeep(req.session._cookieJar); // see tough-cookie issue #59
    tough.CookieJar.deserialize(jar, function (err, cookieJar) {
      if (err) {
        return;
      }
      cookieJar.getCookieString(destination.url, function(err, cookies){
        if (err) {
          return;
        }
        if (cookies) {
          headers.cookie = headers.cookie ? headers.cookie + '; ' + cookies : cookies;
        }
      });
    });
  }
  return getRequestImpl(method, urlUtils.parse(logoutUrl), headers, destination);
};

exports.getRequest = function (req, accessToken) {
  var headers = backendHeaders.getHeaders(req, accessToken);
  var tracer = req.loggingContext.getTracer(__filename);
  return getRequestImpl(req.method, req.internalUrl, headers, req.internalUrl.destination, tracer);
};

function getRequestImpl(method, parsedUrl, headers, destination, tracer) {
  var proxyUri = exports.buildProxyUri(destination);
  var opts = {
    method: method,
    protocol: parsedUrl.protocol,
    hostname: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.path,
    agent: agents.get(parsedUrl.protocol, proxyUri, destination.proxyType === 'OnPremise'),
    rejectUnauthorized: !(destination.strictSSL === false),
    headers: headers
  };
  if (headers.host) { // So socket does not use host header as target (allows differing host header)
    opts['servername'] = parsedUrl.hostname;
  }
  var useSSL = /^https/i.test(opts.protocol);
  if (useSSL && opts.agent.options && opts.agent.options.ca) { // fixes leaking ssl sockets in node
    opts.ca = opts.agent.options.ca;
  }
  if (tracer) {
    traceUtil.traceBackendRequest(tracer, parsedUrl.href, opts);
  }
  return useSSL ? https.request.bind(undefined, opts) : http.request.bind(undefined, opts);
}

exports.buildProxyUri = function (destination) {
  var proxyHost = destination.proxyHost;
  var proxyPort = destination.proxyPort;
  if (!proxyHost) {
    return;
  }
  var hasProtocol = /^https?:\/\//i.test(proxyHost);
  if (hasProtocol) {
    return proxyHost + ':' + proxyPort;
  }
  return 'http://' + proxyHost + ':' + proxyPort;
};

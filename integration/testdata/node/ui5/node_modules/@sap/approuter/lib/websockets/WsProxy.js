'use strict';

var http = require('http');
var cookieParser = require('cookie-parser');
var util = require('util');
var VError = require('verror').VError;
var WebSocket = require('ws');
var Session = require('express-session').Session;

var agents = require('../backend-request/agents');
var attachRouterConfig = require('../middleware/attach-router-config');
var buildProxyUri = require('../backend-request/options').buildProxyUri;
var ConnectionHandler = require('./ConnectionHandler');
var connectUtils = require('../connect/utils');
var getHeaders = require('../backend-request/headers').getHeaders;
var isAuthorized = require('../middleware/authorization-handler');
var loggerUtil = require('../utils/logger');
var loginProvider = require('../middleware/login-provider');
var pathRewriter = require('../middleware/path-rewriter');
var pathUtil = require('../utils/path-util');
var urlUtils = require('../utils/url-utils');
var whitelistUtils = require('../utils/whitelist-utils');

module.exports = WsProxy;

function WsProxy(app) {
  this._app = app;
  this._server = null;
}

WsProxy.prototype.close = function (callback) {
  if (this._server) {
    this._server.close(callback);
    this._server = undefined;
  } else {
    process.nextTick(callback);
  }
};

WsProxy.prototype.listen = function (httpServer) {
  if (this._server) {
    throw new Error('Websocket server already running!');
  }

  this._server = new WebSocket.Server({
    server: httpServer,
    verifyClient: verifyClient.bind(null, this._app)
  });
  this._server.on('connection', function serverConnection(incoming) {
    var req = incoming.upgradeReq;
    var handler = new ConnectionHandler(req.loggingContext);
    handler.onOpen(incoming, req.backendSocket);
  });
};

function verifyClient(app, info, cb) {
  var req = info.req;
  connectUtils.setPropertiesToRequest(req, app);
  req.sessionStore = app.get('memoryStore');
  req.loggingContext = loggerUtil.createRequestContext(req);
  var tracer = getTracer(req);
  tracer.debug('[websockets] incoming request url: %s', req.url);
  attachRouterConfig(req, null, function (err) {
    if (err) {
      return reportError(err, tracer, cb);
    }
    if (!req.routerConfig.appConfig.websockets.enabled) {
      return authorizationRequired(req, cb, 'websockets are disabled');
    }
    try {
      checkAllowedOrigins(req, info.origin);
      req.internalUrl = getInternalUrl(req);
    } catch (err) {
      return reportError(err, tracer, cb);
    }
    if (pathUtil.isPublicPath(req)) {
      return createBackendConnection(req, cb);
    }
    checkLoggedUser(req, function (shouldCreateConnection) {
      if (!shouldCreateConnection) {
        return cb.apply(null, arguments);
      }
      createBackendConnection(req, cb);
    });
  });
}

function checkLoggedUser(req, cb) {
  var app = req.app;
  cookieParser(app.get('sessionCookieKey'))(req, null, function (err) {
    if (err) {
      return reportError(err, getTracer(req), cb);
    }
    var sessionID = req.signedCookies[app.get('cookieName')];
    if (!sessionID) {
      return authenticationRequired(req, cb);
    }
    app.get('memoryStore').get(sessionID, function (err, sess) {
      req.sessionID = sessionID;
      req.session = new Session(req, sess);
      if (loginProvider.isLoginRequired(req)) {
        return authenticationRequired(req, cb);
      }
      if (!isAuthorized(req)) {
        return authorizationRequired(req, cb);
      }
      cb(true);
    });
  });
}

function reportError(err, tracer, cb) {
  if (err.status !== 403 && err.status !== 404) {
    tracer.error(err);
  } else {
    tracer.debug(err);
  }
  var status = err.status || 500;
  return cb(false, status, getErrorMessage(status, err.message, tracer));
}

function createBackendConnection(req, cb) {
  var targetUrl = req.internalUrl;
  var url = targetUrl.href;
  var tracer = getTracer(req);
  tracer.debug('[websockets] connecting to backend server: %s', url);
  var outgoing;

  try {
    outgoing = new WebSocket(url, {
      agent: agents.get(targetUrl.protocol, buildProxyUri(targetUrl.destination)),
      headers: getHeaders(req),
      rejectUnauthorized: !(targetUrl.destination.strictSSL === false)
    });
  } catch (err) {
    return reportError(new VError(err, 'Could not connect to backend server'), tracer, cb);
  }
  var errorHandler = function (err) {
    reportError(new VError(err, 'Outgoing connection error occurred'), tracer, cb);
  };
  outgoing.on('error', errorHandler);
  outgoing.on('open', function () {
    tracer.debug('[websockets] outgoing connection opened');
    req.backendSocket = outgoing;
    outgoing.removeListener('error', errorHandler);
    cb(true);
  });
}

function checkAllowedOrigins(req, origin) {
  var wsAllowedOrigins = req.routerConfig.wsAllowedOrigins || getDefaultAllowedOrigin(req);
  if (!origin || !whitelistUtils.matchWhitelist(wsAllowedOrigins, origin)) {
    var error = new Error(origin ? util.format("origin '%s' is not allowed", origin) : 'missing origin header');
    error.status = 403;
    throw error;
  }
}

function getInternalUrl(req) {
  var targetURL = pathRewriter(req);
  if (!targetURL || !targetURL.destination || !targetURL.href || targetURL.href.charAt(0) === '/') {
    var error = new Error('not able to match the web socket request to any configured backend');
    error.status = 404;
    throw error;
  }
  return targetURL;
}

function authenticationRequired(req, cb) {
  cb(false, 401, getErrorMessage(401, 'Authentication required', getTracer(req)));
}

function authorizationRequired(req, cb, message) {
  cb(false, 403, getErrorMessage(403, message || 'Not authorized', getTracer(req)));
}

function getDefaultAllowedOrigin(req) {
  var appRouterUrl = urlUtils.parse(urlUtils.buildAppRouterUrl(req));
  var wsAllowedOrigin = [{
    protocol: appRouterUrl.protocol.slice(0, -1),
    host: appRouterUrl.hostname,
    port: appRouterUrl.port
  }];
  getTracer(req).debug('[websockets] using default allowed origin:', wsAllowedOrigin);
  return wsAllowedOrigin;
}

function getTracer(req) {
  return req.loggingContext.getTracer(__filename);
}

function getErrorMessage(status, message, tracer) {
  tracer.debug('[websockets] %s', message);
  return process.env.NODE_ENV === 'development' ? message : http.STATUS_CODES[status];
}

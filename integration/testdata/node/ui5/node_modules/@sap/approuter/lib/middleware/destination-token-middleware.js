'use strict';

var destinationTokenHandler = require('./destination-token-handler');
var jwtDecode = require('jwt-decode');
var expiresAt = require('../passport/utils').getExpiresAt;
var destinationUtils = require('../utils/destination-utils');
var sessionExt = require('../utils/session-ext');
var uaaUtils = require('../utils/uaa-utils');
var url = require('url');


module.exports = function (req, res, next) {

  validateBackendDestinationScenario (req, function(err, isBackendDestinationScenario){
    if (err){
      return next(err);
    }
    if (!isBackendDestinationScenario) {
      return next();
    }

    shouldAskAuthDestinationToken(req, function(err, askForToken){
      if (err) {
        return next(err);
      }
      if (!askForToken) {
        return next();
      }
      destinationTokenHandler.replaceUserToken(req, function(err, userExchangeToken) {

        if (err) { return next(err); }
        var destinationName = req.internalUrl.route.destination;
        destinationUtils.getBackendDestinationASync(destinationName, userExchangeToken, function (err, backendDestination){
          if (err){
            return next(err);
          }
          if (req.internalUrl.destination.authentication === 'OAuth2SAMLBearerAssertion' &&
            (!backendDestination || !backendDestination.authTokens || !backendDestination.authTokens[0])) {
            return next('Cannot get authTokens for backend destination');
          }
          if (backendDestination.authTokens && backendDestination.authTokens[0].hasOwnProperty('error')){
            return next(backendDestination.authTokens[0].error);
          }
          if (!backendDestination.destinationConfiguration){
            return next('Cannot get destination configuration');
          }
          if (!backendDestination.destinationConfiguration.URL){
            return next('Cannot get backend destination URL');
          }
          var authToken = backendDestination.authTokens ? backendDestination.authTokens[0].value : null;
          updateInternalUrl(req, backendDestination);
          var tokenDecoded = jwtDecode(userExchangeToken);
          sessionExt.update(req.session, function(// eslint-disable-next-line
            session) {
            if (!req.session.user.destinations){
              req.session.user.destinations = [];
            }
            if (!req.session.user.destinationUserExchangeToken){
              req.session.user.destinationUserExchangeToken = {};
            }
            if (!req.session.user.destinations[destinationName]){
              req.session.user.destinations[destinationName] = {};
            }
            if (!req.session.user.destinations[destinationName].authToken){
              req.session.user.destinations[destinationName].authToken = {};
            }
            req.session.user.destinationUserExchangeToken = {token: userExchangeToken, expireDate:  expiresAt(tokenDecoded.exp - tokenDecoded.iat).getTime()};
            if (authToken) {
              req.session.user.destinations[destinationName].authToken = {token: authToken, expireDate: ''};
            }
            return next();
          });
        });
      });
    });
  });
};


function updateInternalUrl(req, backendDestination){
  var destinationUrl = req.internalUrl.destination.url;
  var newDestination = destinationUtils.normalizeDestination(backendDestination.destinationConfiguration);
  var newHref = newDestination.url;
  req.internalUrl.href = req.internalUrl.href.replace(destinationUrl, newHref);
  var newParsedUrl = url.parse(req.internalUrl.href);

  req.internalUrl.protocol = newParsedUrl.protocol;
  req.internalUrl.host = newParsedUrl.host;
  req.internalUrl.hostname = newParsedUrl.hostname;
  req.internalUrl.path = newParsedUrl.path;
  req.internalUrl.pathname = newParsedUrl.pathname;
  req.internalUrl.port = newParsedUrl.port;
}


function validateBackendDestinationScenario (req, cb){
  if (!req || !req.internalUrl || !req.internalUrl.route || !req.internalUrl.route.destination || !req.internalUrl.destination
    || !req.internalUrl.destination.authentication) {
    return cb(null, false);
  }
  uaaUtils.getUaaConfig(req, function (err, uaaOptions) {
    if (err) {
      return cb(err);
    }
    if (!uaaOptions) {
      return cb('Invalid UAA options');
    }
    if (req.internalUrl.destination.authentication !== 'OAuth2SAMLBearerAssertion' && uaaOptions.tenantmode !== 'shared') {
      return cb(null, false);
    }
    if (!req.session || !req.session.user){
      return cb(new Error('Route with backend destination needs oauth authentication'));
    }
    return cb(null, true);
  });
}

function shouldAskAuthDestinationToken(req, cb){

  // TEMPORARY: since the expiration property from the OAuth server response is not sent back to the Destination Service caller,
  // we don't check the expiration of the authToke and call the Destination Service every time.
  /*  var destinationName = req.internalUrl.route.destination;

    if (!req.session.user.destinations || req.session.user.destinations[destinationName]){
      return cb(null, true);
    }

    var destinationTokensCache = req.session.user.destinations[destinationName];
    // authToken exists or expired
    if (!destinationTokensCache.authToken || destinationTokensCache.token.expireDate < Date.now()) { // no token for current business service or token expired - ask for token
      return cb(null, true);
    }
    return cb(null, false);*/

  return cb (null, true);


}


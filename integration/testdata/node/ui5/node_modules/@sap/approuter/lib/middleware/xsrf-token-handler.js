'use strict';

var tokens = require('../utils/csrf-utils')({ 'secretLength': 32 });
var pathUtil = require('../utils/path-util');
var sessionExt = require('../utils/session-ext');

module.exports = {
  /**
   * Checks if a token is required for an incoming request:
   *  - GET and HEAD requests do not require a token (except if they are used to fetch a new token)
   *  - public path requests do not require a token
   *
   * @param req
   * @returns true if a token is required, else false
   */
  isTokenRequired: function(req) {
    if (!pathUtil.isCsrfProtectionEnabled(req)) {
      return false;
    }

    if (isGetRequest(req) || isHeadRequest(req)) {
      return hasTokenFetchHeader(req);
    }

    return !pathUtil.isPublicPath(req);
  },

  isTokenFetchRequest: function(req) {
    return ((isGetRequest(req) || isHeadRequest(req)) && hasTokenFetchHeader(req));
  },

  /**
   * Check a token send by the client
   *
   * @param req
   * @returns {isValid: boolean, details: string}
   */
  checkToken: function (req) {
    var tokenHeader = req.headers['x-csrf-token'];
    if (!tokenHeader) {
      return { isValid: false, details: 'The request does not contain a x-csrf-token' };
    } else {
      if (req.session && req.session.xsrf && tokens.verify(req.session.xsrf.secret, tokenHeader)) {
        return { isValid: true, details: 'The request contains a valid x-csrf-token' };
      } else {
        return { isValid: false, details: 'The request contains an invalid x-csrf-token' };
      }
    }
  },

  /**
   * Returns a new token and stores it in the session (or returns an existing one from the session)
   *
   * @param req
   * @param cb function cb(err, token)
   */
  getToken: function (req, cb) {
    if (!req.session) {
      return cb(new Error('No session established. Failed to store token in session'));
    }
    if (!req.session.xsrf) {
      var token;
      var secret;
      try {
        secret = tokens.secretSync();
        token = tokens.create(secret);
      } catch (err) {
        return cb(err);
      }
      sessionExt.update(req.session, function(session) {
        session.xsrf = session.xsrf || {
          token: token,
          secret: secret
        };
      });
    }
    return cb(null, req.session.xsrf.token);
  }
};

function isGetRequest(req) {
  return req.method === 'GET';
}

function isHeadRequest(req) {
  return req.method === 'HEAD';
}

function hasTokenFetchHeader(req) {
  var tokenHeader = req.headers['x-csrf-token'];
  return ((tokenHeader) ? tokenHeader.toLowerCase() === 'fetch' : false);
}

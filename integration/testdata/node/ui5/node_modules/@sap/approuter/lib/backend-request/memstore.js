'use strict';


/*
 * express-session
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var session = require('express-session');
var util = require('util');

/**
 * Shim setImmediate for node.js < 0.10
 * @private
 */

/**
 * A session store in memory.

 * @param {Object} [options]
 * @param {Number} [options.timeout] Session timeout (in minutes). Number has to be positive.
 * @public
 */

var Store = session.Store;

function MemoryStore(options) {
  Store.call(this);
  options = options || {};
  this.options = {};
  this.sessions = {};
  this.sessionTimers = {};
  if (options.timeout && options.timeout < 1) {
    options.timeout = null;
  }

  this.options.timeout = (options.timeout || 15) * 6;

  var getSessionFn = getSession.bind(this);
  var self = this;
  this.sessionChecker = setInterval(function() {
    for (var sessionId in self.sessionTimers) {
      if (--self.sessionTimers[sessionId] <= 0) {
        var sessionObject = getSessionFn(sessionId);
        self.emit('timeout', sessionObject);
        self.destroy(sessionId);
      }
    }
  },
  10 * 1000); // runs every 10 seconds
  return this;
}

/**
 * Inherit from Store.
 *
 */

util.inherits(MemoryStore, Store);

/**
 * Get all active sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.all = function all(callback) {
  var sessionIds = Object.keys(this.sessions);
  var sessions = {};

  var getSessionFn = getSession.bind(this);
  for (var i = 0; i < sessionIds.length; i++) {
    var sessionId = sessionIds[i];
    sessions[sessionId] = getSessionFn(sessionId);
  }

  callback && callback(null, sessions);
};

/**
 * Clear all sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.clear = function clear(callback) {
  this.sessions = {};
  this.sessionTimers = {};
  callback && callback();
};

/**
 * Destroy the session associated with the given session ID.
 *
 * @param {string} sessionId
 * @public
 */

MemoryStore.prototype.destroy = function destroy(sessionId, callback) {
  if (!this.sessions[sessionId]) {
    return callback && callback();
  }

  var session = this.sessions[sessionId];
  delete this.sessionTimers[sessionId];
  delete this.sessions[sessionId];
  this.emit('destroy', JSON.parse(session));
  callback && callback();
};

/**
 * Fetch session by the given session ID. Never returns error.
 *
 * @param {string} sessionId
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.get = function get(sessionId, callback) {
  callback(null, getSessionResetTimeout.call(this, sessionId));
};

/**
 * Commit the given session associated with the given sessionId to the store.
 *
 * @param {string} sessionId
 * @param {object} session
 * @param {function} callback
 * @public
 */

/**
 * Get number of active sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.length = function length(callback) {
  callback(null, Object.keys(this.sessions).length);
};

MemoryStore.prototype.set = function set(sessionId, session, callback) {
  storeSession.call(this, sessionId, session);
  resetTimer.call(this, sessionId);
  callback && callback();
};

/**
 * Touch the given session object associated with the given session ID.
 *
 * @param {string} sessionId
 * @param {object} session
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.touch = function touch(sessionId, session, callback) {
  var currentSession = getSessionResetTimeout.call(this, sessionId);

  if (currentSession) {
    // update expiration
    currentSession.cookie = session.cookie;
    storeSession.call(this, sessionId, currentSession);
  }

  callback && callback();
};

/**
 * Reset timer for session
 *
 * @param {string} sessionId
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.resetSessionTimer = function(sessionId, callback) {
  var error = null;
  if (this.sessionTimers[sessionId]) {
    resetTimer.call(this, sessionId);
  } else {
    error = new Error('Could not reset session timer! Session ' + sessionId + ' missing!');
  }
  return callback && callback(error);
};


/**
 * Get session timeout
 * @returns {Number} Default session timeout in minutes
 * @public
 */

MemoryStore.prototype.getDefaultSessionTimeout = function() {
  return this.options.timeout / 6;
};

/**
 * Get specific session timer
 * @param sessionId
 * @param callback callback(err, time), time is in minutes
 * @public
 */

MemoryStore.prototype.getSessionTimeout = function (sessionId, callback) {
  var timer = this.sessionTimers[sessionId];
  callback(timer ? null : new Error('Invalid session'), timer && timer / 6);
};

/**
   * Updates the session in the memstore by applying function change to it without changing the session timer.
   *
   * @param {string} sessionId
   * @param {function} change A function that changes the session - function change(session)
   * @param {boolean} resetTimer defaults to true
   */
MemoryStore.prototype.update = function(sessionId, change, shouldResetTimer) {
  var session = getSession.call(this, sessionId);
  if (!session) {
    return change(null);
  }
  change(session);
  storeSession.call(this, sessionId, session);
  if (shouldResetTimer !== false) {
    resetTimer(sessionId);
  }
};

/**
 * Get session from the store and reset timeout.
 * @param {string} sessionId
 * @returns {object} session
 * @private
 */
function getSessionResetTimeout(sessionId) {
  var session = getSession.call(this, sessionId);
  if (session) {
    resetTimer.call(this, sessionId);
  }
  return session;
}

/**
 * Get session from the store.
 * @param {string} sessionId
 * @returns {object} session
 * @private
 */
function getSession(sessionId) {
  var sessionJson = this.sessions[sessionId];
  if (sessionJson) {
    var session = JSON.parse(sessionJson);
    Object.defineProperty(session, 'id', { value: sessionId });
    return session;
  }
}

/**
 * Reset timer for session
 * @param {string} sessionId
 * @private
 */
function resetTimer(sessionId) {
  var isUpdate = this.sessionTimers.hasOwnProperty(sessionId);
  this.sessionTimers[sessionId] = this.options.timeout;
  if (isUpdate) {
    this.emit('update', sessionId, this.options.timeout / 6); // in minutes
  }
}

function storeSession(sessionId, session) {
  var isUpdate = this.sessions.hasOwnProperty(sessionId);
  this.sessions[sessionId] = JSON.stringify(session, function(key, value) {
    return (key === 'id') ? undefined : value; // skip id
  });
  if (isUpdate) {
    this.emit('update', sessionId);
  }
}

module.exports = MemoryStore;

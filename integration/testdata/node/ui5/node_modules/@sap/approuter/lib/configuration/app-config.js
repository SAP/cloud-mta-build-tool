'use strict';

var _ = require('lodash');
var fs = require('fs');
var path = require('path');
var VError = require('verror').VError;
var safeRegex = require('safe-regex');
var xsenv = require('@sap/xsenv');
var loggingUtils = require('../utils/logger');
var tracer = loggingUtils.getTracer(__filename);
var logger = loggingUtils.getLogger('/Configuration');
var fsUtils = require('../utils/fs-utils');
var validators = require('./validators');
var prettyPrint = require('../utils/pretty-print');
var configurationUtils = require('../utils/configuration-utils');
var destinationUtils = require('../utils/destination-utils');
var dynamicRoutingUtils = require('../utils/dynamic-routing-utils');

exports.loadConfiguration = function (directory, source, envDestinations, appName, isStart) {
  var configuration = _.isObject(source) ? source : loadXsAppFromFile(directory, source);
  // get additional destinations from the destinations service
  if (isStart){
    destinationUtils.attachDestinationServiceConfig(configuration.routes,envDestinations);
  }
  validators.validateXsApp(configuration, envDestinations, directory);
  if (configuration.authenticationMethod === 'none') {
    logger.warning('No authentication will be used when accessing backends. Scopes defined in routes will be ignored.');
  }

  configuration.routes = configuration.routes || [];
  var hasLocalDirSet = configuration.routes.some(function (currentRoute) {
    return !!currentRoute.localDir;
  });

  if (!hasLocalDirSet) {
    if (fsUtils.isDirectory(path.join(directory, 'resources'))) {
      configuration.routes.push({
        source: '^/(.*)',
        localDir: 'resources'
      });
    } else {
      if (!dynamicRoutingUtils.isDynamicRouting()) {
        logger.info('xs-app.json: Application does not have directory for static resources!');
      }
    }
  }

  processRoutes(configuration, appName);
  handleReplace(configuration, directory);
  configuration.errorPage = generateErrorPageMap(configuration);
  return configuration;
};

function loadXsAppFromFile(directory, source) {
  var fullFileName = path.join(directory, source);

  try {
    tracer.info('Loading configuration from ', fullFileName);
    return JSON.parse(fs.readFileSync(fullFileName, 'utf8'));
  } catch (e) {
    throw new VError(e, 'Invalid content in %s', fullFileName);
  }
}

function generateErrorPageMap(configuration) {
  return (configuration.errorPage || []).reduce(function (result, errorRoute) {
    var arr = Array.isArray(errorRoute.status) ? errorRoute.status : [errorRoute.status];
    arr.forEach(function (status) {
      result.set(status, errorRoute.file);
    });
    return result;
  }, new Map());
}

function handleReplace(configuration, workingDir) {
  var pathToDefaultServices = path.join(workingDir, 'default-services.json');
  configuration.routes.forEach(function (route) {
    if (route.replace) {
      var varsMap = {};
      if (route.replace.vars) {
        varsMap = route.replace.vars.reduce(function (result, varName) {
          result[varName] = process.env[varName];
          return result;
        }, varsMap);
      }
      var services = route.replace.services ?
        xsenv.getServices(route.replace.services, pathToDefaultServices) : {};

      var common = _.intersection(Object.keys(varsMap), Object.keys(services));
      if (common.length > 0) {
        throw new VError('Route has invalid replace object - colliding services and vars: %s', common);
      }
      route.replace.view = _.extend(varsMap, services);
    }
  });
}

function processRoutes(configuration, appName) {
  if (!appName) {
    logger.info("Replacing $XSAPPNAME will not take place - 'xsappname' property not found in UAA configuration.");
  }

  configuration.routes.forEach(function (currentRoute) {
    currentRoute.source = configurationUtils.constructRegExp(currentRoute.source);
    if (!safeRegex(currentRoute.source)) {
      logger.warning('Route with source ', currentRoute.source, ' is vulnerable to ReDoS attacks');
    }
    if (currentRoute.authenticationType === 'none' && currentRoute.scope) {
      logger.warning('Route with source ', currentRoute.source, ' does not require authentication. Defined scopes will be ignored.');
    }

    if (currentRoute.csrfProtection === true &&
       (currentRoute.authenticationType === 'none' || configuration.authenticationMethod === 'none')) {
      logger.warning('Route with source %s is public and will not be protected from CSRF', currentRoute.source);
    }

    currentRoute.scope = processScope(currentRoute.scope, appName);
  });
  if (tracer.isEnabled('debug')) {
    tracer.debug('Routes after being processed', JSON.stringify(configuration.routes, prettyPrint.prettyPrintRegExp, 2));
  }
}

function processScope(scope, appName) {
  if (_.isString(scope) || Array.isArray(scope)) {
    return replaceApplicationName(scope, appName);
  }
  for (var httpMethod in scope) {
    scope[httpMethod] = replaceApplicationName(scope[httpMethod], appName);
  }
  return scope;
}

function replaceApplicationName(scope, appName) {
  scope = _.isString(scope) ? [scope] : scope;
  if (!appName) {
    return scope;
  }
  return scope.map(function (scopeName) {
    return scopeName.replace(/^\$XSAPPNAME/, appName);
  });
}

'use strict';

var _ = require('lodash');
var tokenUtils = require('./token-utils');
var syncRequest = require('sync-request');
var loggingUtils = require('./logger');
var logger = loggingUtils.getLogger('/Destination service');
var validators = require('../configuration/validators');
var xsenv = require('@sap/xsenv');
var async = require('async');
var request = require('request');

exports.attachDestinationServiceConfig = attachDestinationServiceConfig;
exports.adjustDestinationProperties = adjustDestinationProperties;
exports.normalizeDestinationProperties = normalizeDestinationProperties;
exports.getDestinationsAsync = getDestinationsAsync;
exports.getDestinationServiceCredentials = getDestinationServiceCredentials;
exports.getBackendDestinationASync = getBackendDestinationASync;
exports.normalizeDestination = normalizeDestination;

function attachDestinationServiceConfig(routes, envDestination) {
  var destinationOptions;
  var serviceDestinations = [];
  var missDestinations = _.map(
    _.uniqBy(routes, function (route) {
      return route.destination;
    }), 'destination').filter(function (destinationName) {
      return destinationName && envDestination && !envDestination[destinationName];
    });
  if (missDestinations && missDestinations.length > 0) {
    logger.info('Looking for the missing environment destinations metadata: %s in destination service', missDestinations);
    destinationOptions = tokenUtils.getDestinationTokenAndUrl();
    if (!destinationOptions) {
      logger.error('missing access token for destination service');
      return;
    }
    missDestinations.forEach(function (destination) {
      var destinationMetaData = getDestinationSync(destination, destinationOptions);
      if (destinationMetaData) {
        serviceDestinations.push(destinationMetaData);
      }
    });
    normalizeDestinationProperties(serviceDestinations);
    validators.validateDestinations(serviceDestinations, true);
    adjustDestinationProperties(serviceDestinations);
    serviceDestinations.forEach(function (destination) {
      envDestination[destination.name] = destination;
    });
  }
}


function getDestinationSync(destinationName, destinationOptions) {
  var url = destinationOptions.uri + '/destination-configuration/v1/subaccountDestinations/' + destinationName;
  var requestOptions = {
    headers: {
      'accept': 'application/json;charset=utf-8',
      'Authorization': 'Bearer ' + destinationOptions.token.accessToken
    }
  };
  var res = syncRequest('GET', url, requestOptions);
  if (!res || res.statusCode !== 200) {
    if (res.statusCode === 404) {
      logger.warning('Route %s not found in the destination service', destinationName);
    } else {
      logger.error('Bad response from destination services : %s', JSON.stringify(res));
    }
    return;
  }
  var destinationMetaData;
  try {
    destinationMetaData = JSON.parse(res.body);
  } catch (err) {
    logger.error(err, 'unexpected response from destination service. Expected json, got: "%s"', res.body);
    return;
  }
  return destinationMetaData;
}

function adjustDestinationProperties(destinations) {
  destinations.forEach(function (destination) {
    if (destination.proxyType === 'OnPremise') {
      var credentials = xsenv.cfServiceCredentials({tag: 'connectivity'});
      destination['proxyHost'] = credentials.onpremise_proxy_host;
      destination['proxyPort'] = credentials.onpremise_proxy_port;
    }
    _.defaults(destination, {
      timeout: 30000
    });
  });
}

function normalizeDestinationProperties(destinations) {
  if (!destinations) {
    return;
  }
  if (!Array.isArray(destinations)){
    throw new Error('destinations type invalid, array is expected');
  }
  destinations.forEach(function (destination, i, destinations) {
    if (destinations[i].Authentication){ // if it destination from destinations service
      destinations[i] = normalizeDestination (destination);
      destinations[i].forwardAuthToken = destinations[i].forwardAuthToken === 'true' || destinations[i].forwardAuthToken === true;
      destinations[i].preserveHostHeader = destinations[i].preserveHostHeader === 'true' || destinations[i].preserveHostHeader === true;
      if (destinations[i].timeout && !isNaN(destinations[i].timeout)) {
        destinations[i].timeout = _.toSafeInteger(destinations[i].timeout);
      }
    }
  });
}

function normalizeDestination (destination){
  if (!destination) {
    return;
  }
  var keys = Object.keys(destination);
  var n = keys.length;
  var newobj = {};
  var key;
  while (n--) {
    key = keys[n];
    if (key === 'URL'){
      newobj[key.toLowerCase()] = destination[key];
    } else
    {
      var newKey = key.substr(0, 1).toLowerCase() + key.substr(1);
      newobj[newKey] = destination[key];
    }
  }
  return newobj;
}

function getRequestOptions (req, destination, cb) {

  if (!req.app.destinationToken || !req.app.destinationToken.accessToken){
    return cb ('Destination token is missing');
  }

  var credentials = getDestinationServiceCredentials ();
  if (!credentials) {
    return cb ('Destination service is not bound');
  }

  cb (null, {
    url: credentials.uri + '/destination-configuration/v1/subaccountDestinations/' + destination,
    headers: {
      'accept': 'application/json;charset=utf-8',
      'Authorization': 'Bearer ' + req.app.destinationToken.accessToken
    }
  });
}

function getDestinationsAsync(req, xsAppJson, cb) {
  var destinationsMap = {};
  var destinationsData = [];
  var errorMessage;
  var destinationFromEnv;

  if (!xsAppJson) {
    return cb ('xsAppJson is missing');
  }

  async.forEach(xsAppJson.routes, function (route, callback) {

    if (!route.destination || destinationsMap[route.destination]) {
      return callback();
    }

    destinationFromEnv = getDestinationFromEnv (route.destination);
    if (destinationFromEnv) {
      if (!destinationsMap[route.destination]) {
        destinationsMap[route.destination] = true;
        destinationsData.push(destinationFromEnv);
      }
      callback();
    } else {
      getRequestOptions(req, route.destination, function (error, requestOptions) {
        if (error) {
          logger.error(error);
          errorMessage = 'Destination ' + route.destination + ' not defined in Application router environment ' +
            'and destination service not bound. Define destination ' + route.destination +
            ' in application environment or bind Application router to destination service and ' +
            'define the destination in SAP Cloud cockpit';
          return callback (errorMessage);
        }
        request.get(requestOptions, function onResponse(err, res) {
          if (err || !res || res.statusCode !== 200 || !res.body) {
            logger.error('Error during calling destination service for destination ' + route.destination);
            errorMessage = 'Destination ' + route.destination + ' not defined in Application router environment ' +
              'or destination service. Define destination ' + route.destination +
              ' in application environment or define the destination in SAP Cloud cockpit';
            return callback(errorMessage);
          }
          if (!destinationsMap[route.destination]) {
            destinationsMap[route.destination] = true;
            destinationsData.push(JSON.parse(res.body));
          }
          return callback();
        });
      });
    }
  }, function (err){
    cb (err, destinationsData);
  });
}

function getDestinationServiceCredentials() {
  var errorOccurred;
  var credentials;
  try {
    credentials = xsenv.cfServiceCredentials({tag: 'destination'});
  } catch (e) {
    errorOccurred = true;
  }
  if (errorOccurred || !credentials) {
    logger.error('Error during loading of destination service credentials. Verify Destination service is bound');
    return null;
  }
  return credentials;
}

function getDestinationFromEnv (destinationName) {

  if (!('destinations' in process.env)) {
    return null;
  }

  var destinations = JSON.parse(process.env.destinations);
  var matchingDestinations = destinations.filter (function (destination) {
    return destination.name === destinationName;
  });
  if (matchingDestinations.length === 0) {
    return null;
  }

  return matchingDestinations [0];
}


function getRequestOptionsWithAuthToken (destinationName, token, cb) {

  var credentials = getDestinationServiceCredentials ();
  if (!credentials) {
    return cb ('Destination service is not bound');
  }
  cb (null, {
    url: credentials.uri + '/destination-configuration/v1/destinations/' + destinationName,
    headers: {
      'accept': 'application/json;charset=utf-8',
      'Authorization': 'Bearer ' + token
    }
  });
}


function getBackendDestinationASync (destinationName, token, cb){
  if (!destinationName) {
    return cb('Cannot get backend destination, destination name is missing');
  }
  if (!token) {
    return cb('Cannot get backend destination, token is missing');
  }
  var errorMessage;
  getRequestOptionsWithAuthToken(destinationName, token, function (error, requestOptions) {
    if (error) {
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || res.statusCode !== 200 || !res.body) {
        errorMessage = 'Error during calling destination service for destination ' + destinationName;
        logger.error(errorMessage);
        return cb(errorMessage);
      }
      try {
        var destination = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destination);
    });
  });
}


